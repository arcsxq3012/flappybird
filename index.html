<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="theme-color" content="#ffb7c9" />
<title>Flappy Bird</title>
<style>
   @font-face{
     font-family: "Arcade";
     src: url("assets/arcade.ttf") format("truetype");
     font-display: swap;
   }
   :root { color-scheme: light; }
   html, body { height: 100%; margin: 0; background:#ffb7c9; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
   .wrap { height: 100%; display:flex; align-items:center; justify-content:center; padding: 10px; box-sizing: border-box; }
   canvas { width: min(96vw, 420px); height: auto; border-radius: 16px; background:#ffb7c9; box-shadow: 0 16px 60px rgba(0,0,0,.28); touch-action: manipulation; }
   /* Pop up boxes stay system font */
   .overlay{
     position: fixed; inset: 0; display:none; align-items:center; justify-content:center;
     background: rgba(0,0,0,.45); padding: 18px; overflow: hidden;
     font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
   }
   .card{
     width: min(92vw, 420px);
     background: rgba(255,255,255,.92);
     border: 2px solid rgba(0,0,0,.18);
     border-radius: 14px;
     padding: 16px;
     color: #111;
     box-shadow: 0 18px 60px rgba(0,0,0,.35);
     text-align: center;
     position: relative;
     z-index: 2;
     font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
   }
   .title{ font-size: 18px; font-weight: 900; margin: 0 0 8px; color:#111; }
   .title.wonGreen{ color:#34c759; }
   .text{ margin: 0 0 12px; color: rgba(0,0,0,.88); line-height: 1.2; font-weight: 900; font-size: 20px; }
   .row{ display:flex; gap: 10px; justify-content:center; flex-wrap: wrap; }
   button{
     appearance:none; border: 0; border-radius: 12px; padding: 12px 14px;
     font-weight: 900; cursor: pointer; min-width: 120px;
     font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
   }
   .ghost{ background: rgba(0,0,0,.08); color: rgba(0,0,0,.85); }
   .noRed{ background:#ff3b30; color:#fff; }
   .yesGreen{ background:#34c759; color:#fff; }
   .small{ margin-top: 10px; font-size: 12px; color: rgba(0,0,0,.6); }
   .qAnim{
     display:inline-block;
     opacity: 0;
     transform: translateY(-18px) scale(.98);
     animation: qDrop .55s ease forwards, qPulse .9s ease .55s 1;
   }
   @keyframes qDrop{
     0%{ opacity:0; transform: translateY(-18px) scale(.98); }
     70%{ opacity:1; transform: translateY(7px) scale(1.02); }
     100%{ opacity:1; transform: translateY(0) scale(1); }
   }
   @keyframes qPulse{
     0%{ transform: scale(1); }
     45%{ transform: scale(1.03); }
     100%{ transform: scale(1); }
   }
   .btnSmall{ flex: 0 0 110px; min-width: 110px; padding: 10px 12px; }
   .btnBig{ flex: 1 1 220px; min-width: 220px; padding: 14px 16px; }
   .btnMega{ flex: 1 1 320px; min-width: 320px; padding: 16px 18px; font-size: 18px; }
   .rainLayer{
     position: absolute; inset: 0; pointer-events: none; z-index: 1; overflow: hidden;
   }
   .dropEmoji{
     position: absolute; top: -10vh; font-size: 26px;
     animation-name: fall; animation-timing-function: linear; animation-fill-mode: forwards;
     filter: drop-shadow(0 6px 10px rgba(0,0,0,.18));
     opacity: 0.95;
   }
   @keyframes fall{
     0%{ transform: translateY(-10vh) rotate(0deg); }
     100%{ transform: translateY(120vh) rotate(360deg); }
   }
</style>
</head>
<body>
<div class="wrap">
<canvas id="c" width="360" height="640"></canvas>
</div>
<div class="overlay" id="overlay">
<div class="rainLayer" id="rainLayer"></div>
<div class="card">
<p class="title" id="ovTitle">YOU WON!</p>
<p class="text qAnim" id="ovText">ë‚˜ëž‘ ì‚¬ê·ˆëž˜?</p>
<div class="row" id="ovButtons">
<button class="ghost" id="btnNext">NEXT â€ºâ€º</button>
<button class="noRed" id="btnNoK">ì•„ë‹ˆ</button>
<button class="yesGreen" id="btnYesK">ë„¤</button>
<button class="ghost" id="btnReplay">Play again</button>
</div>
<div class="small" id="ovSmall">Tap anywhere to flap during the game.</div>
</div>
</div>
<script>
   const HEART_NEED = 3;
   const YAY_TEXT = "Yay";
   const RAIN_EMOJIS = ["ðŸ«¶ðŸ¼","ðŸ¦–","ðŸŒ»"];
   const ASSETS = {
     bg: "assets/bg.png",
     clouds: "assets/clouds.png",
     ground: "assets/ground.png",
     bird: "assets/bird.png",
     pipe: "assets/pipe.png",
     heart: "assets/heart.png",
     btnStart: "assets/btn_start.png"
   };
   const canvas = document.getElementById("c");
   const ctx = canvas.getContext("2d");
   const overlay = document.getElementById("overlay");
   const rainLayer = document.getElementById("rainLayer");
   const ovTitle = document.getElementById("ovTitle");
   const ovText = document.getElementById("ovText");
   const btnNext = document.getElementById("btnNext");
   const btnYesK = document.getElementById("btnYesK");
   const btnNoK  = document.getElementById("btnNoK");
   const btnReplay = document.getElementById("btnReplay");
   const W = canvas.width, H = canvas.height;
   canvas.style.touchAction = "manipulation";
   ctx.imageSmoothingEnabled = false;
   const img = {};
   function loadImage(key, src) {
     return new Promise((resolve) => {
       const im = new Image();
       im.onload = () => { img[key] = im; resolve(true); };
       im.onerror = () => resolve(false);
       im.src = src;
     });
   }
   const rand = (a,b)=> a + Math.random()*(b-a);
   const state = {
     mode: "loading",
     t: 0,
     score: 0,
     best: 0,
     hearts: 0
   };
   const bird = { x: 110, y: H*0.45, r: 12, vy: 0 };
   const phys = { g: 0.52, flap: -8.8, maxFall: 12.5 };
   const PIPE_W = 54;
   const PIPE_GAP = 160;
   const PIPE_SPACING = 190;
   const SPEED = 2.6;
   const pipes = [];
   const hearts = [];
   const ground = { y: H - 64, h: 64, scroll: 0 };
   let rejectStep = 0;
   let rainTimer = null;
   function arcadeFont(sizePx) {
     return `900 ${sizePx}px "Arcade", system-ui, -apple-system, Segoe UI, Roboto, Arial`;
   }
   function outlinedText(text, x, y, size, fill, outline, outlineW, align) {
     ctx.save();
     ctx.font = arcadeFont(size);
     ctx.textAlign = align || "left";
     ctx.textBaseline = "alphabetic";
     ctx.lineJoin = "round";
     ctx.miterLimit = 2;
     ctx.lineWidth = outlineW;
     ctx.strokeStyle = outline;
     ctx.strokeText(text, x, y);
     ctx.fillStyle = fill;
     ctx.fillText(text, x, y);
     ctx.restore();
   }
   function outlinedTextShadow(text, x, y, size, fill, outline, outlineW, shadow, align) {
     ctx.save();
     ctx.font = arcadeFont(size);
     ctx.textAlign = align || "left";
     ctx.textBaseline = "alphabetic";
     if (shadow) {
       ctx.fillStyle = shadow;
       ctx.fillText(text, x + 3, y + 3);
     }
     ctx.lineJoin = "round";
     ctx.miterLimit = 2;
     ctx.lineWidth = outlineW;
     ctx.strokeStyle = outline;
     ctx.strokeText(text, x, y);
     ctx.fillStyle = fill;
     ctx.fillText(text, x, y);
     ctx.restore();
   }
   function rectCircle(rx, ry, rw, rh, cx, cy, cr) {
     const nx = Math.max(rx, Math.min(cx, rx + rw));
     const ny = Math.max(ry, Math.min(cy, ry + rh));
     const dx = cx - nx, dy = cy - ny;
     return (dx*dx + dy*dy) <= cr*cr;
   }
   function spawnSet(x) {
     const topH = rand(90, H - (ground.h + 120) - PIPE_GAP);
     const gapY = topH + PIPE_GAP;
     pipes.push({ x, topH, gapY, passed: false });
     hearts.push({
       x: x + PIPE_W + 50,
       y: (topH + gapY) * 0.5 + rand(-22, 22),
       taken: false
     });
   }
   function stopRain() {
     if (rainTimer) clearInterval(rainTimer);
     rainTimer = null;
     rainLayer.innerHTML = "";
   }
   function startRain() {
     stopRain();
     const makeOne = () => {
       const el = document.createElement("div");
       el.className = "dropEmoji";
       el.textContent = RAIN_EMOJIS[(Math.random() * RAIN_EMOJIS.length) | 0];
       const left = Math.random() * 100;
       const dur = rand(1.8, 3.8);
       const size = rand(18, 34);
       el.style.left = left + "vw";
       el.style.fontSize = size + "px";
       el.style.animationDuration = dur + "s";
       rainLayer.appendChild(el);
       setTimeout(() => {
         if (el && el.parentNode) el.parentNode.removeChild(el);
       }, dur * 1000 + 200);
     };
     for (let i = 0; i < 18; i++) setTimeout(makeOne, i * 40);
     rainTimer = setInterval(() => {
       for (let i = 0; i < 3; i++) makeOne();
     }, 140);
   }
   function resetAskButtonsDefault() {
     btnNoK.className = "noRed";
     btnYesK.className = "yesGreen";
     btnNoK.textContent = "ì•„ë‹ˆ";
     btnYesK.textContent = "ë„¤";
   }
   function restartQuestionAnim() {
     ovText.classList.remove("qAnim");
     void ovText.offsetWidth;
     ovText.classList.add("qAnim");
   }
   function show(el, on) { el.style.display = on ? "" : "none"; }
   function resetToStart() {
     state.mode = "start";
     state.t = 0;
     state.score = 0;
     state.hearts = 0;
     bird.x = 110;
     bird.y = H*0.45;
     bird.vy = 0;
     pipes.length = 0;
     hearts.length = 0;
     spawnSet(W + 70);
     spawnSet(W + 70 + PIPE_SPACING);
     spawnSet(W + 70 + PIPE_SPACING*2);
     overlay.style.display = "none";
     rejectStep = 0;
     stopRain();
     resetAskButtonsDefault();
   }
   function startGame() { state.mode = "play"; }
   function lose() {
     if (state.mode !== "play") return;
     state.mode = "lose";
     state.best = Math.max(state.best, state.score);
     showOverlay("lose");
   }
   function win() {
     if (state.mode !== "play") return;
     state.mode = "win";
     state.best = Math.max(state.best, state.score);
     showOverlay("win");
   }
   function flap() {
     if (state.mode === "start") startGame();
     if (state.mode !== "play") return;
     bird.vy = phys.flap;
   }
   function setAskStep0() {
     rejectStep = 0;
     ovTitle.textContent = "";
     ovTitle.classList.remove("wonGreen");
     ovText.textContent = "ë‚˜ëž‘ ì‚¬ê·ˆëž˜?";
     restartQuestionAnim();
     stopRain();
     show(btnNext, false);
     show(btnNoK, true);
     show(btnYesK, true);
     show(btnReplay, false);
     resetAskButtonsDefault();
   }
   function setAskStep1() {
     rejectStep = 1;
     ovTitle.textContent = "";
     ovTitle.classList.remove("wonGreen");
     ovText.textContent = "Are you sure?";
     restartQuestionAnim();
     stopRain();
     show(btnNext, false);
     show(btnNoK, true);
     show(btnYesK, true);
     show(btnReplay, false);
     btnNoK.textContent = "yes";
     btnYesK.textContent = "no";
     btnNoK.className = "noRed btnSmall";
     btnYesK.className = "yesGreen btnBig";
   }
   function setAskStep2() {
     rejectStep = 2;
     ovTitle.textContent = "";
     ovTitle.classList.remove("wonGreen");
     ovText.textContent = "I will give you ONE more try!";
     restartQuestionAnim();
     stopRain();
     show(btnNext, false);
     show(btnNoK, false);
     show(btnYesK, true);
     show(btnReplay, false);
     btnYesK.textContent = "ì‘, ì‚¬ê·€ìž";
     btnYesK.className = "yesGreen btnMega";
   }
   function showOverlay(type) {
     overlay.style.display = "flex";
     if (type === "win") {
       ovTitle.textContent = "YOU WON!";
       ovTitle.classList.add("wonGreen");
       ovText.textContent = `SCORE ${state.score} BEST ${state.best}`;
       restartQuestionAnim();
       stopRain();
       show(btnNext, true);
       show(btnNoK, false);
       show(btnYesK, false);
       show(btnReplay, true);
       btnReplay.textContent = "Play again";
       rejectStep = 0;
       resetAskButtonsDefault();
       return;
     }
     if (type === "ask") { setAskStep0(); return; }
     if (type === "yay") {
       ovTitle.textContent = "";
       ovTitle.classList.remove("wonGreen");
       ovText.textContent = YAY_TEXT;
       restartQuestionAnim();
       show(btnNext, false);
       show(btnNoK, false);
       show(btnYesK, false);
       show(btnReplay, true);
       btnReplay.textContent = "Play again";
       startRain();
       return;
     }
     if (type === "lose") {
       ovTitle.textContent = "Try again";
       ovTitle.classList.remove("wonGreen");
       ovText.textContent = `SCORE ${state.score} HEARTS ${state.hearts}/${HEART_NEED}`;
       restartQuestionAnim();
       stopRain();
       show(btnNext, false);
       show(btnNoK, false);
       show(btnYesK, false);
       show(btnReplay, true);
       btnReplay.textContent = "Play again";
     }
   }
   btnReplay.addEventListener("click", () => resetToStart());
   btnNext.addEventListener("click", () => showOverlay("ask"));
   btnYesK.addEventListener("click", () => {
     if (rejectStep === 0) { showOverlay("yay"); return; }
     if (rejectStep === 1) { showOverlay("yay"); return; }
     if (rejectStep === 2) { showOverlay("yay"); return; }
   });
   btnNoK.addEventListener("click", () => {
     if (rejectStep === 0) { setAskStep1(); return; }
     if (rejectStep === 1) { setAskStep2(); return; }
   });
   function drawHeartShape(x, y, s) {
     ctx.save();
     ctx.translate(x, y);
     ctx.scale(s, s);
     ctx.beginPath();
     ctx.moveTo(0, 4);
     ctx.bezierCurveTo(0, -6, -12, -6, -12, 4);
     ctx.bezierCurveTo(-12, 14, 0, 18, 0, 26);
     ctx.bezierCurveTo(0, 18, 12, 14, 12, 4);
     ctx.bezierCurveTo(12, -6, 0, -6, 0, 4);
     ctx.closePath();
     ctx.fillStyle = "#ff2e7a";
     ctx.fill();
     ctx.restore();
   }
   function update() {
     state.t++;
     if (state.mode === "play") {
       bird.vy += phys.g;
       if (bird.vy > phys.maxFall) bird.vy = phys.maxFall;
       bird.y += bird.vy;
       for (const p of pipes) {
         p.x -= SPEED;
         if (!p.passed && p.x + PIPE_W < bird.x) {
           p.passed = true;
           state.score++;
         }
         const topRect = { x: p.x, y: 0, w: PIPE_W, h: p.topH };
         const botRect = { x: p.x, y: p.gapY, w: PIPE_W, h: ground.y - p.gapY };
         if (rectCircle(topRect.x, topRect.y, topRect.w, topRect.h, bird.x, bird.y, bird.r)) lose();
         if (rectCircle(botRect.x, botRect.y, botRect.w, botRect.h, bird.x, bird.y, bird.r)) lose();
       }
       for (const h of hearts) {
         h.x -= SPEED;
         if (!h.taken) {
           const dx = bird.x - h.x, dy = bird.y - h.y;
           const rr = (bird.r + 12);
           if ((dx*dx + dy*dy) <= rr*rr) {
             h.taken = true;
             state.hearts++;
             if (state.hearts >= HEART_NEED) win();
           }
         }
       }
       if (pipes.length && pipes[0].x + PIPE_W < -70) {
         pipes.shift();
         spawnSet(pipes[pipes.length - 1].x + PIPE_SPACING);
       }
       while (hearts.length && hearts[0].x < -90) hearts.shift();
       if (bird.y - bird.r < 0) { bird.y = bird.r; bird.vy = 0; }
       if (bird.y + bird.r > ground.y) lose();
       ground.scroll = (ground.scroll + SPEED) % W;
     }
     if (state.mode === "start") {
       bird.y = H*0.45 + Math.sin(state.t * 0.06) * 6;
     }
   }
   function draw() {
     ctx.clearRect(0, 0, W, H);
     if (img.bg) ctx.drawImage(img.bg, 0, 0, W, H);
     else { ctx.fillStyle = "#ffc1d0"; ctx.fillRect(0, 0, W, H); }
     if (img.clouds) {
       ctx.globalAlpha = 0.95;
       ctx.drawImage(img.clouds, 0, 0, W, H);
       ctx.globalAlpha = 1;
     } else {
       ctx.fillStyle = "rgba(255,255,255,.9)";
       ctx.beginPath();
       ctx.arc(70, H-140, 26, 0, Math.PI*2);
       ctx.arc(96, H-145, 30, 0, Math.PI*2);
       ctx.arc(128, H-140, 22, 0, Math.PI*2);
       ctx.fill();
       ctx.beginPath();
       ctx.arc(W-90, H-170, 24, 0, Math.PI*2);
       ctx.arc(W-60, H-176, 30, 0, Math.PI*2);
       ctx.arc(W-30, H-170, 22, 0, Math.PI*2);
       ctx.fill();
     }
     for (const p of pipes) {
       if (img.pipe) {
         ctx.drawImage(img.pipe, p.x, p.gapY, PIPE_W, ground.y - p.gapY);
         ctx.save();
         ctx.translate(p.x + PIPE_W, p.topH);
         ctx.scale(-1, -1);
         ctx.drawImage(img.pipe, 0, 0, PIPE_W, p.topH);
         ctx.restore();
       } else {
         ctx.fillStyle = "#ff4a7b";
         ctx.fillRect(p.x, 0, PIPE_W, p.topH);
         ctx.fillRect(p.x, p.gapY, PIPE_W, ground.y - p.gapY);
         ctx.fillStyle = "rgba(0,0,0,.18)";
         ctx.fillRect(p.x, p.topH - 10, PIPE_W, 10);
         ctx.fillRect(p.x, p.gapY, PIPE_W, 10);
       }
     }
     for (const h of hearts) {
       if (h.taken) continue;
       if (img.heart) ctx.drawImage(img.heart, h.x - 12, h.y - 12, 24, 24);
       else drawHeartShape(h.x, h.y, 0.8);
     }
     if (img.ground) {
       const y = ground.y;
       const x0 = -ground.scroll;
       for (let x = x0; x < W; x += W) ctx.drawImage(img.ground, x, y, W, ground.h);
     } else {
       ctx.fillStyle = "rgba(255,255,255,.35)";
       ctx.fillRect(0, ground.y, W, ground.h);
       ctx.fillStyle = "rgba(0,0,0,.08)";
       ctx.fillRect(0, ground.y, W, 3);
     }
     if (img.bird) {
       ctx.save();
       ctx.translate(bird.x, bird.y);
       const rot = Math.max(-0.5, Math.min(0.8, bird.vy / 11));
       ctx.rotate(rot);
       ctx.drawImage(img.bird, -18, -14, 36, 28);
       ctx.restore();
     } else {
       ctx.save();
       ctx.translate(bird.x, bird.y);
       const rot = Math.max(-0.5, Math.min(0.8, bird.vy / 11));
       ctx.rotate(rot);
       ctx.fillStyle = "#ffe66d";
       ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
       ctx.fillStyle = "rgba(0,0,0,.6)";
       ctx.beginPath(); ctx.arc(4,-3,2,0,Math.PI*2); ctx.fill();
       ctx.fillStyle = "#ffb000";
       ctx.beginPath(); ctx.moveTo(10,1); ctx.lineTo(18,5); ctx.lineTo(10,9); ctx.closePath(); ctx.fill();
       ctx.restore();
     }
     /* HUD in Arcade + white outline */
     outlinedText(`${state.hearts}/${HEART_NEED} â¤`, 14, 26, 18, "rgba(0,0,0,.70)", "#ffffff", 5, "left");
     if (state.mode === "start") {
       /* Title bigger, centered, Arcade + white outline */
       outlinedTextShadow("FLAPPY", W/2, 280, 44, "#ff2e7a", "#ffffff", 7, "rgba(0,0,0,.18)", "center");
       outlinedTextShadow("BIRD",   W/2, 330, 44, "#ff2e7a", "#ffffff", 7, "rgba(0,0,0,.18)", "center");
       /* Start button */
       const bx = W/2 - 105;
       const by = 360;
       const bw = 210;
       const bh = 62;
       if (img.btnStart) {
         ctx.drawImage(img.btnStart, W/2 - 110, 352, 220, 80);
         outlinedText("START", W/2, 400, 26, "#ffffff", "#ffffff", 0, "center");
       } else {
         ctx.fillStyle = "#ff2e7a";
         ctx.fillRect(bx, by, bw, bh);
         ctx.fillStyle = "rgba(0,0,0,.18)";
         ctx.fillRect(bx, by + bh, bw, 6);
         /* Center START inside the box, bigger, Arcade + white outline */
         outlinedText("START", W/2, by + 40, 28, "#ffffff", "#ffffff", 0, "center");
       }
       /* Instructions bigger, centered, Arcade + white outline */
       outlinedText("TAP TO START AND FLAP", W/2, 468, 16, "rgba(0,0,0,.70)", "#ffffff", 5, "center");
       outlinedText("COLLECT 3 HEARTS",      W/2, 492, 16, "rgba(0,0,0,.70)", "#ffffff", 5, "center");
     }
   }
   function onTap() {
     if (overlay.style.display === "flex") return;
     if (state.mode === "loading") return;
     if (state.mode === "start") {
       startGame();
       bird.vy = phys.flap;
       return;
     }
     if (state.mode === "play") flap();
   }
   window.addEventListener("pointerdown", (e) => {
     onTap();
     e.preventDefault();
   }, { passive: false });
   function loop() {
     update();
     draw();
     requestAnimationFrame(loop);
   }
   async function boot() {
     state.mode = "loading";
     await Promise.all(Object.entries(ASSETS).map(([k, src]) => loadImage(k, src)));
     if (document.fonts && document.fonts.load) {
       await document.fonts.load('16px "Arcade"');
       await document.fonts.load('44px "Arcade"');
     }
     resetToStart();
     loop();
   }
   boot();
</script>
</body>
</html>
